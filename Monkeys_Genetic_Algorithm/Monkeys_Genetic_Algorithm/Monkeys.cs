namespace Monkeys {
    using Carter;
    using Carter.ModelBinding;
    using Carter.Request;
    using Carter.Response;
    using Microsoft.AspNetCore.Http;
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Net.Http.Headers;
    using System.Threading.Tasks;
    using static System.Console;
    
    public class HomeModule : CarterModule {
        public HomeModule () {
            Post ("/try", async (req, res) => {
                var t = await req.Bind<TryRequest>(); //parse the req to a TryRequest.
                if(t.length == 0){
                    var assess_len_req = new AssessRequest{id = t.id, genomes = new List<string>{""}};
                    var assess_len_res = await PostFitnessAssess(assess_len_req);
                    t.length = assess_len_res.scores[0]; 
                }
                GeneticAlgorithm(t); //start this // should have thread that run geneticAlgorithm and one that will return the Post method right away.
                await Task.Delay (0);
                return; //this will return to client and just a empty Ok response
            });
        }
        
        async Task<AssessResponse> PostFitnessAssess (AssessRequest areq) {
            await Task.Delay (0);
            var ares = new AssessResponse ();
            var client = new HttpClient ();
            
            client.BaseAddress = new Uri ("http://localhost:8091/");
            client.DefaultRequestHeaders.Accept.Clear ();
            client.DefaultRequestHeaders.Accept.Add (
                new MediaTypeWithQualityHeaderValue ("application/json"));
            
            WriteLine ($"..... POST /assess send {areq}");
            var hrm = await client.PostAsJsonAsync ("/assess", areq);
            hrm.EnsureSuccessStatusCode ();

            ares = await hrm.Content.ReadAsAsync <AssessResponse> ();
            WriteLine ($"..... receive response {ares}");
            return ares;
        }
        
        async Task PostClientTop (TopRequest treq) {
            await Task.Delay (0);
            var client = new HttpClient ();
            
            client.BaseAddress = new Uri ($"http://localhost:{treq.id}/");
            client.DefaultRequestHeaders.Accept.Clear ();
            client.DefaultRequestHeaders.Accept.Add (
                new MediaTypeWithQualityHeaderValue ("application/json"));
            
            WriteLine ($"..... POST /top send {treq}");
            var hrm = await client.PostAsJsonAsync ("/top", treq);
            hrm.EnsureSuccessStatusCode ();
            return;
        }
        
        private Random _random = new Random (1);
        
        private double NextDouble () {
            lock (this) {
                return _random.NextDouble ();
            }
        }
        
        private int NextInt (int a, int b) {
            lock (this) {
                return _random.Next (a, b);
            }
        }

        int ProportionalRandom (int[] weights, int sum) {
            var val = NextDouble () * sum;
            
            for (var i = 0; i < weights.Length; i ++) {
                if (val < weights[i]) return i;
                
                val -= weights[i];
            }
            
            WriteLine ($"***** Unexpected ProportionalRandom Error");
            return 0;
        }

        async void GeneticAlgorithm (TryRequest treq) { //async functions could run in separate threads.
                                                        //if a function is not async, the function will only run wwhen you call it.
                                                        //however, if the function is async, there is a task that is automatically
                                                        //generated and it will keep running in a separate thread.
            WriteLine ($"..... GeneticAlgorithm {treq}");
            await Task.Delay (0);
            
            var id = treq.id;
            var monkeys = treq.monkeys;
            if (monkeys % 2 != 0) monkeys += 1;
            var length = treq.length;
            var crossover = treq.crossover / 100.0 ;
            var mutation = treq.mutation / 100.0;
            var limit = treq.limit;
            if (limit == 0) limit = 1000;
            var para = treq.parallel;

            var topscore = int.MaxValue; //initialise the topscore to the maximum of int32 bit
                                            //we will compare the topscore to the topscore of each generation,
                                            //so topscore will eventually decreases.
            
            //Generate the first group of genomes (randomly), but only once.
            //The later genomes will be generated by the genetic algorithm

            var first_genomes_array = new string[monkeys];
            var first_genomes = first_genomes_array.Select(g =>{
                var genome_string = Enumerable.Range(0,length)
                                    .Select(i => (char) NextInt(32, 127));
                return String.Join("", genome_string);  
            }).ToList();
            var areq = new AssessRequest{id = id, genomes = first_genomes};
            var topreq = new TopRequest{id = id};
                  
            for (int loop = 0; loop < limit; loop++) { // the main loop/generation evolution.
                                                        //the loop only goes up to the limit.
                AssessResponse ares = await PostFitnessAssess(areq);
                var gen_topscore = ares.scores.Min();
                
                if(gen_topscore < topscore){
                    topscore = gen_topscore;
                    var topscore_genome = areq.genomes[ares.scores.IndexOf(gen_topscore)];
                    topreq.loop = loop;
                    topreq.score = topscore;
                    topreq.genome = topscore_genome;
                    if (gen_topscore == 0){
                        await PostClientTop(topreq);
                        break;
                    }else{
                        await PostClientTop(topreq);
                    }
                }
                    
                var weights = ares.scores.Select(s => (ares.scores.Max()-s+1));
                var sum_weight = weights.Sum();
                
                if(para){
                    var new_genomes = ParallelEnumerable.Range(1, monkeys/2) //or ParallelEnumerable
                                        .SelectMany( i => {
                                            var index1 = ProportionalRandom(weights.ToArray(), sum_weight);
                                            var index2 = ProportionalRandom(weights.ToArray(), sum_weight);
                                            var p1 = areq.genomes[index1];
                                            var p2 = areq.genomes[index2];

                                            var c1 = p1;
                                            var c2 = p2;
                                            
                                            if(NextDouble() < crossover){
                                                var crossover_index = NextInt(0, length);
                                                c1 = p1.Substring(0,crossover_index) + p2.Substring(crossover_index, length-crossover_index);
                                                c2 = p2.Substring(0,crossover_index) + p1.Substring(crossover_index, length-crossover_index);
                                            }
                                            if(NextDouble() < mutation){
                                                var index = NextInt(0, length);
                                                var character = (char) NextInt(32, 127);    
                                                c1 = c1.Substring(0, index) + character + c1.Substring(index+1, length-index-1);
                                            }
                                            if(NextDouble() < mutation){
                                                var index = NextInt(0, length);
                                                var character = (char) NextInt(32, 127);    
                                                c2 = c2.Substring(0, index) + character + c2.Substring(index+1, length-index-1);
                                            }
                                            return new[]{c1, c2};
                                        }).ToList();
                    areq.id = id;
                    areq.genomes = new_genomes;
                }else{
                    var new_genomes = Enumerable.Range(1, monkeys/2) //or ParallelEnumerable
                                        .SelectMany( i => {
                                            var index1 = ProportionalRandom(weights.ToArray(), sum_weight);
                                            var index2 = ProportionalRandom(weights.ToArray(), sum_weight);
                                            var p1 = areq.genomes[index1];
                                            var p2 = areq.genomes[index2];

                                            var c1 = p1;
                                            var c2 = p2;
                                            
                                            if(NextDouble() < crossover){
                                                var crossover_index = NextInt(0, length);
                                                c1 = p1.Substring(0,crossover_index) + p2.Substring(crossover_index, length-crossover_index);
                                                c2 = p2.Substring(0,crossover_index) + p1.Substring(crossover_index, length-crossover_index);
                                            }
                                            if(NextDouble() < mutation){
                                                var index = NextInt(0, length);
                                                var character = (char) NextInt(32, 127);    
                                                c1 = c1.Substring(0, index) + character + c1.Substring(index+1, length-index-1);
                                            }
                                            if(NextDouble() < mutation){
                                                var index = NextInt(0, length);
                                                var character = (char) NextInt(32, 127);    
                                                c2 = c2.Substring(0, index) + character + c2.Substring(index+1, length-index-1);
                                            }
                                            return new[]{c1, c2};
                                        }).ToList();
                    areq.id = id;
                    areq.genomes = new_genomes;
                }
            }
        }
    }
    
    // public class TargetRequest {
        // public int id { get; set; }
        // public bool parallel { get; set; }
        // public string target { get; set; }
        // public override string ToString () {
            // return $"{{{id}, {parallel}, \"{target}\"}}";
        // }  
    // }    

    public class TryRequest {
        public int id { get; set; }
        public bool parallel { get; set; }
        public int monkeys { get; set; }
        public int length { get; set; }
        public int crossover { get; set; }
        public int mutation { get; set; }
        public int limit { get; set; }
        public override string ToString () {
            return $"{{{id}, {parallel}, {monkeys}, {length}, {crossover}, {mutation}, {limit}}}";
        }
    }
    
    public class TopRequest {
        public int id { get; set; }
        public int loop { get; set; }
        public int score { get; set; }
        public string genome { get; set; }
        public override string ToString () {
            return $"{{{id}, {loop}, {score}, {genome}}}";
        }  
    }    
    
    public class AssessRequest {
        public int id { get; set; }
        public List<string> genomes { get; set; }
        public override string ToString () {
            return $"{{{id}, #{genomes.Count}}}";
        }  
    }
    
    public class AssessResponse {
        public int id { get; set; }
        public List<int> scores { get; set; }
        public override string ToString () {
            return $"{{{id}, #{scores.Count}}}";
        }  
    }   
}

namespace Monkeys {
    using Carter;
    using Microsoft.AspNetCore.Builder;
    using Microsoft.Extensions.DependencyInjection;

    public class Startup {
        public void ConfigureServices (IServiceCollection services) {
            services.AddCarter ();
        }

        public void Configure (IApplicationBuilder app) {
            app.UseRouting ();
            app.UseEndpoints( builder => builder.MapCarter ());
        }
    }
}

namespace Monkeys {
    using Microsoft.AspNetCore.Hosting;
    using Microsoft.Extensions.Hosting;
    using Microsoft.Extensions.Logging;

    public class Program {
        public static void Main (string[] args) {
//          var host = Host.CreateDefaultBuilder (args)
//              .ConfigureWebHostDefaults (webBuilder => webBuilder.UseStartup<Startup>())

            var urls = new[] {"http://localhost:8081"};
            
            var host = Host.CreateDefaultBuilder (args)
            
                .ConfigureLogging (logging => {
                    logging
                        .ClearProviders ()
                        .AddConsole ()
                        .AddFilter (level => level >= LogLevel.Warning);
                })
                
                .ConfigureWebHostDefaults (webBuilder => {
                    webBuilder.UseStartup<Startup> ();
                    webBuilder.UseUrls (urls);  // !!!
                })
                
                .Build ();
            
            System.Console.WriteLine ($"..... starting on {string.Join (", ", urls)}");            
            host.Run ();
        }
    }
}

